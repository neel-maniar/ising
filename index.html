<!DOCTYPE html>
<html>
<head>
  <title>Optimized Ising Model</title>
  <style>
    canvas { image-rendering: pixelated; border: 1px solid black; }
    #controls { margin-top: 10px; }
  </style>
</head>
<body>

<canvas id="canvas"></canvas>
<canvas id="graphCanvas" width="400" height="100" style="border:1px solid black; display:block; margin-top:10px;"></canvas>

<div id="controls">
  <label>Temperature: <span id="tempVal" style="display:inline-block; width:30px; text-align:right;">2.5</span></label>
  <input type="range" id="temp" min="0.1" max="5" step="0.1" value="2.5">

  <label style="margin-left:20px;">Magnetization: 
    <span id="magVal" style="display:inline-block; width:50px; text-align:right; font-family: monospace;">0</span>
  </label>

  <label style="margin-left:20px;">Speed: <span id="speedVal" style="display:inline-block; width:30px; text-align:right;">1</span> steps/frame</label>
  <input type="range" id="speed" min="1" max="50" step="1" value="1">

  <label style="margin-left:20px;">Boundary:</label>
  <label><input type="radio" name="boundary" value="periodic" checked> Periodic</label>
  <label><input type="radio" name="boundary" value="fixedUp"> Fixed +1</label>
  <label><input type="radio" name="boundary" value="fixedDown"> Fixed -1</label>

  <label style="margin-left:20px;">FPS: <span id="fpsVal" style="display:inline-block; width:40px; text-align:right;">0</span></label>
</div>

<script>
const L = 300;   // lattice size
const scale = 1;  // pixels per lattice site

const canvas = document.getElementById("canvas");
canvas.width = L * scale;
canvas.height = L * scale;
const ctx = canvas.getContext("2d");

const graphCanvas = document.getElementById("graphCanvas");
const gCtx = graphCanvas.getContext("2d");
const maxPoints = graphCanvas.width;
let magHistory = [];

// Worker
const worker = new Worker("worker.js");
worker.postMessage({ type: "init", L: L, beta: 1/2.5 });

// FPS tracking
let lastFrameTime = performance.now();
const fpsVal = document.getElementById("fpsVal");

function updateFPS() {
  const now = performance.now();
  const delta = now - lastFrameTime;
  const fps = 1000 / delta;
  fpsVal.textContent = fps.toFixed(1);
  lastFrameTime = now;
}

// Draw lattice setup
const img = ctx.createImageData(L, L);
const tempCanvas = document.createElement("canvas");
tempCanvas.width = L;
tempCanvas.height = L;
const tempCtx = tempCanvas.getContext("2d");

function drawLattice(lattice) {
  for (let i = 0; i < L; i++) {
    for (let j = 0; j < L; j++) {
      const idx = (i*L + j)*4;
      const spin = lattice[i*L + j];
      const color = spin > 0 ? 255 : 0;
      img.data[idx] = color;
      img.data[idx+1] = color;
      img.data[idx+2] = color;
      img.data[idx+3] = 255;
    }
  }
  tempCtx.putImageData(img, 0, 0);
  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(tempCanvas, 0,0,L*scale,L*scale);
}

function drawGraph() {
  gCtx.clearRect(0,0,graphCanvas.width,graphCanvas.height);
  gCtx.beginPath();
  gCtx.moveTo(0, graphCanvas.height/2 - magHistory[0]*(graphCanvas.height/2));
  for (let i = 1; i < magHistory.length; i++) {
    const x = i;
    const y = graphCanvas.height/2 - magHistory[i]*(graphCanvas.height/2);
    gCtx.lineTo(x, y);
  }
  gCtx.strokeStyle = "red";
  gCtx.lineWidth = 1;
  gCtx.stroke();
}

// Handle worker messages
worker.onmessage = (e) => {
  if(e.data.type === "frame") {
    drawLattice(e.data.lattice);
    const M = e.data.mag;
    document.getElementById("magVal").textContent = M.toFixed(2);

    magHistory.push(M);
    if (magHistory.length > maxPoints) magHistory.shift();
    drawGraph();

    updateFPS();
  }
};

// Controls
const tempSlider = document.getElementById("temp");
const tempVal = document.getElementById("tempVal");
tempSlider.addEventListener("input", () => {
  const T = parseFloat(tempSlider.value);
  tempVal.textContent = T;
  const beta = 1 / T;
  worker.postMessage({ type: "setBeta", beta: beta });
});

const speedSlider = document.getElementById("speed");
const speedVal = document.getElementById("speedVal");
speedSlider.addEventListener("input", () => {
  const steps = parseInt(speedSlider.value);
  speedVal.textContent = steps;
  worker.postMessage({ type: "setSpeed", steps: steps });
});

const boundaryRadios = document.querySelectorAll('input[name="boundary"]');
boundaryRadios.forEach(radio => {
  radio.addEventListener('change', () => {
    worker.postMessage({ type: "setBoundary", boundary: radio.value });
  });
});
</script>

</body>
</html>
